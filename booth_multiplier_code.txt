module booth_multiplier( 
input clk, 
input start, 
input [3:0] multiplicand, // Signed 4-bit 
input [3:0] multiplier, // Signed 4-bit 
output reg [7:0] product, // Signed 8-bit result 
output reg done 
); 
 
reg [4:0] A, S; // Extended for sign bit 
reg [4:0] P; // Partial product (A/S/M) 
reg [3:0] Q; // Multiplier 
reg Q_1; 
reg [3:0] count; 
reg busy; 
 
always @(posedge clk) begin 
if (start) begin 
A = {multiplicand[3], multiplicand}; // Sign-extend 
S = ~A + 1;  // 2’s complement of A 
P = 5’b00000; 
Q = multiplier; 
Q_1 = 1’b0; 
count = 4; 
busy = 1; 
done = 0; 
end 
else if (busy) begin 
case ({Q[0], Q_1}) 
2’b01: P = P + A; // Add A 
2’b10: P = P + S; // Subtract A 
default: ; // No operation 
endcase 
 
// Arithmetic right shift {P, Q, Q_1} 
{P, Q, Q_1} = {P[4], P, Q, Q_1} >> 1; 
count = count - 1; 
if (count == 0) begin 
product = {P[3:0], Q}; 
 
 
done = 1; 
busy = 0; 
end 
end 
end 
endmodule 